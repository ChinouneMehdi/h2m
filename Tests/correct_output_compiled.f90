! This is a compilation of some of the CORRECT output from the h2m
! tool during one of its last runs of the summer in 2017.
!
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_anon_tests
USE, INTRINSIC :: iso_c_binding
implicit none
! Found excessively long name.
! TYPE, BIND(C) :: /Users/manderso/Desktop/summerwork/h2mgit/Tests/anon_tests.h:1:1)
!     INTEGER(C_INT) :: a
!     INTEGER(C_INT) :: b
!     INTEGER(C_INT) :: c
! END TYPE /Users/manderso/Desktop/summerwork/h2mgit/Tests/anon_tests.h:1:1)
! Found illegal type.
! WARNING_ANONYMOUS(TYPE(/Users/manderso/Desktop/summerwork/h2mgit/Tests/anon_tests.h:1:1)), public, BIND(C) :: thing
! Found illegal type.
! TYPE, BIND(C) :: composite
!     INTEGER(C_INT) :: x
!     WARNING_ANONYMOUS(TYPE(/Users/manderso/Desktop/summerwork/h2mgit/Tests/anon_tests.h:10:3)) :: thing
! END TYPE composite
END MODULE module_anon_tests
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_array_tests
USE, INTRINSIC :: iso_c_binding
implicit none
INTEGER(C_INT), parameter, public :: array_const = 10
TYPE, BIND(C) :: simple
    INTEGER(C_INT) :: x
END TYPE simple
INTEGER(C_INT), public, BIND(C) :: my_int_array(10)
TYPE(C_PTR), public, BIND(C) :: my_double_array(200)
CHARACTER(C_CHAR), BIND(C) :: my_char_array(2) = RESHAPE((/'a', 'b'/), (/2/))
CHARACTER(C_CHAR), BIND(C) :: my_other_char_array(2, 3) = RESHAPE((/'a', 'b', 'c', 'c', 'd', 'e'/), (/2, 3/))
CHARACTER(C_CHAR), parameter, public :: my_literal_char(15) = "Literal string"
INTEGER(C_INT), public, BIND(C) :: my_2d_array(4, 4)
INTEGER(C_INT), BIND(C) :: my_other_2d_array(1, 2) = RESHAPE((/97, 98/), (/1, 2/))
REAL(C_DOUBLE), BIND(C) :: my_2d_double_array(2, 2) = RESHAPE((/2.500000e+00, -1.300000e+00, 0.000000e+00, 5.300000e+00/), (/2, 2/))
REAL(C_DOUBLE), public, BIND(C) :: my_3d_array(3, 5, 8)
TYPE(simple), public, BIND(C) :: struct_array(5, 2)
INTEGER(C_INT), public, BIND(C) :: my_array(1)
INTEGER(C_INT), public, BIND(C) :: my_var_array(10)
REAL(C_FLOAT), public, BIND(C) :: my_float_array(15, 11, 12)
INTERFACE
INTEGER(C_INT) FUNCTION my_variable_function(my_array, other) BIND(C)
    USE iso_c_binding, only: C_DOUBLE, C_INT
    import
    INTEGER(C_INT), DIMENSION(*) :: my_array
    REAL(C_DOUBLE), DIMENSION(*) :: other
END FUNCTION my_variable_function

SUBROUTINE my_scary_var_subroutine(my_array, my_array_2) BIND(C)
    USE iso_c_binding, only: C_CHAR, C_DOUBLE
    import
    CHARACTER(C_CHAR), DIMENSION(*) :: my_array
    REAL(C_DOUBLE), DIMENSION(*) :: my_array_2
END SUBROUTINE my_scary_var_subroutine

INTEGER(C_INT) FUNCTION my_other_function(my_array, x, other) BIND(C)
    USE iso_c_binding, only: C_DOUBLE, C_INT
    import
    INTEGER(C_INT), DIMENSION(4, 5) :: my_array
    INTEGER(C_INT), value :: x
    REAL(C_DOUBLE), DIMENSION(x+4, x*2-3) :: other
END FUNCTION my_other_function

INTEGER(C_INT) FUNCTION other_function(my_array, other) BIND(C)
    USE iso_c_binding, only: C_DOUBLE, C_INT
    import
    INTEGER(C_INT), DIMENSION(10) :: my_array
    REAL(C_DOUBLE), DIMENSION(10, 20) :: other
END FUNCTION other_function

INTEGER(C_INT) FUNCTION static_array_func(my_array) BIND(C)
    USE iso_c_binding, only: C_INT
    import
    INTEGER(C_INT), DIMENSION(5) :: my_array
END FUNCTION static_array_func

END INTERFACE
END MODULE module_array_tests
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_macro_tests
USE, INTRINSIC :: iso_c_binding
implicit none
INTEGER(C_INT), parameter, public :: my_integer = 45
REAL(C_DOUBLE), parameter, public :: my_double = 34.5
INTEGER(C_INT), parameter, public :: my_binary = B'10101101'
INTEGER(C_INT), parameter, public :: my_binary_caps = B'000'
! Found unrecognized macro.
! my_not_binary 0B20
! Found unrecognized macro.
! another_not_bin b10101
INTEGER(C_INT), parameter, public :: my_odd_hex = Z'00ff'
INTEGER(C_INT), parameter, public :: yet_another_hex = Z'ff00'
INTEGER(C_INT), parameter, public :: my_octal = O'5234'
INTEGER(C_INT), parameter, public :: not_octal = 08323
INTEGER(C_LONG), parameter, public :: my_other_not_octal = 0832
INTEGER(C_LONG), parameter, public :: my_other_int = 345
INTEGER(C_LONG), parameter, public :: my_unsigned_int = 45
INTEGER(C_INT), parameter, public :: my_hex = Z'345'
INTEGER(C_INT), parameter, public :: my_other_hex = Z'fedab'
! Found unrecognized macro.
! my_not_hex 0xfg01
! Found unrecognized macro.
! other_not_hex xf01a
INTEGER(C_LONG), parameter, public :: my_long = 123
CHARACTER(1), parameter, public :: my_char = 'a'
CHARACTER(8), parameter, public :: my_string = "a string"
INTERFACE
SUBROUTINE my_arg_macro(x, y) BIND(C)
!  x + y
END SUBROUTINE my_arg_macro
END INTERFACE
INTERFACE
SUBROUTINE swap_trick(x, y) BIND(C)
!  {x ^= y; y ^= x; x ^= y;}
END SUBROUTINE swap_trick
END INTERFACE
INTERFACE
SUBROUTINE multi_line(x) BIND(C)
!  {  \
!     x++;  \
!     x--;  \
! }
END SUBROUTINE multi_line
END INTERFACE
END MODULE module_macro_tests
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_crazy_struct
USE, INTRINSIC :: iso_c_binding
implicit none
TYPE, BIND(C) :: other
    INTEGER(C_LONG) :: v
    INTEGER(C_INT) :: t
    CHARACTER(C_CHAR) :: other_array(2, 3)
END TYPE other
! Found duplicate identifier.
! TYPE, BIND(C) :: other
!     TYPE(other)::other_other
! END TYPE other
REAL(C_DOUBLE), public, BIND(C) :: x
TYPE, BIND(C) :: my_union
    REAL(C_DOUBLE) :: y
    INTEGER(C_LONG) :: x
END TYPE my_union
TYPE, BIND(C) :: thing
    INTEGER(C_INT) :: x
    REAL(C_DOUBLE) :: y
    CHARACTER(C_CHAR) :: z
    CHARACTER(C_CHAR) :: m(6)
    TYPE(C_PTR) :: n
    TYPE(other) :: l
    INTEGER(C_INT) :: theirs(3)
    TYPE(C_PTR) :: double_ptr
    TYPE(C_FUNPTR) :: function_pointer
END TYPE thing
TYPE, BIND(C) :: illegal_thing
    TYPE(my_union) :: unicorn
END TYPE illegal_thing
TYPE(thing), public, BIND(C) :: my_thing = thing(4, 2.340000e+00, 'a', "mine", & ! Initial pointer value: 0 set to C_NULL_PTR
C_NULL_PTR, other(100, 10, RESHAPE((/'a', 'b', 'c', 'd', 'e', 'f'/), (/2, 3/))), RESHAPE((/1, 2, 3/), (/3/)), & ! Initial pointer value: &x set to C_NULL_PTR
C_NULL_PTR, & ! Initial pointer value: &a_func set to C_NULL_FUNPTR
C_NULL_FUNPTR)
! Found structure translation failure.
! TYPE(illegal_thing), public, BIND(C) :: my_illegal_thing = illegal_thing(UntranslatableComponent:{5423L})
TYPE(my_union), BIND(C) :: these_unions(2, 1) = RESHAPE((/5.430000e+02, 4.560000e+01/), (/2, 1/))
INTERFACE
INTEGER(C_INT) FUNCTION a_func(y) BIND(C)
    USE iso_c_binding, only: C_INT
    import
    INTEGER(C_INT), value :: y
END FUNCTION a_func

END INTERFACE
END MODULE module_crazy_struct
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_enum_typedef_tests
USE, INTRINSIC :: iso_c_binding
implicit none
ENUM, BIND(C) ! my_stuff
ENUMERATOR :: onething = 0
ENUMERATOR :: twothing = 1
ENUMERATOR :: threething = 2
END ENUM ! my_stuff
ENUM, BIND(C) ! their_stuff
ENUMERATOR :: thingone = 0
ENUMERATOR :: thingtwo = 15
END ENUM ! their_stuff
TYPE, BIND(C) :: my_stuff_t
    INTEGER(C_INT)::my_stuff_t_C_INT
END TYPE my_stuff_t
TYPE, BIND(C) :: integer_pointer
    TYPE(C_PTR)::integer_pointer_C_PTR
END TYPE integer_pointer
TYPE, BIND(C) :: little_struct
    INTEGER(C_INT) :: a
    REAL(C_DOUBLE) :: b
END TYPE little_struct
TYPE, BIND(C) :: other
    TYPE(little_struct)::other_little_struct
END TYPE other
INTERFACE
INTEGER(C_INT) FUNCTION takes_type_def(an_arg, another_arg) BIND(C)
    USE iso_c_binding, only: C_INT
    import
    INTEGER(C_INT), value :: an_arg
    INTEGER(C_INT), value :: another_arg
END FUNCTION takes_type_def

INTEGER(C_INT) FUNCTION takes_other(my_other, b, c) BIND(C)
    USE iso_c_binding, only: C_INT, C_PTR
    import
    TYPE(other), value :: my_other
    INTEGER(C_INT), value :: b
    TYPE(C_PTR), value :: c
END FUNCTION takes_other

END INTERFACE
END MODULE module_enum_typedef_tests
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_function_tests
USE, INTRINSIC :: iso_c_binding
implicit none
TYPE, BIND(C) :: simple
    INTEGER(C_INT) :: a
END TYPE simple
INTERFACE
INTEGER(C_INT) FUNCTION my_simple_function() BIND(C)
    USE iso_c_binding, only: C_INT
    import
END FUNCTION my_simple_function

SUBROUTINE my_simple_subroutine() BIND(C)
    USE iso_c_binding
    import
END SUBROUTINE my_simple_subroutine

REAL(C_DOUBLE) FUNCTION my_double_function(x, y, z) BIND(C)
    USE iso_c_binding, only: C_CHAR, C_DOUBLE, C_INT, C_PTR
    import
    INTEGER(C_INT), value :: x
    TYPE(C_PTR), value :: y
    CHARACTER(C_CHAR), DIMENSION(*) :: z
END FUNCTION my_double_function

SUBROUTINE my_complex_subroutine(v, c, m) BIND(C)
    USE iso_c_binding, only: C_PTR, C_SHORT
    import
    INTEGER(C_SHORT), value :: v
    TYPE(C_PTR), value :: c
    TYPE(C_PTR), value :: m
END SUBROUTINE my_complex_subroutine

REAL(C_LONG_DOUBLE) FUNCTION return_long_double(x, y, z) BIND(C)
    USE iso_c_binding, only: C_FLOAT, C_LONG, C_LONG_DOUBLE, C_SHORT
    import
    INTEGER(C_SHORT), value :: x
    INTEGER(C_LONG), value :: y
    REAL(C_FLOAT), value :: z
END FUNCTION return_long_double

TYPE(simple) FUNCTION return_struct() BIND(C)
    USE iso_c_binding
    import
END FUNCTION return_struct

TYPE(C_PTR) FUNCTION return_struct_pointer() BIND(C)
    USE iso_c_binding, only: C_PTR
    import
END FUNCTION return_struct_pointer

SUBROUTINE more_arrays_etc(x, y, n) BIND(C)
    USE iso_c_binding, only: C_CHAR, C_INT
    import
    INTEGER(C_INT), value :: x
    TYPE(simple), value :: y
    CHARACTER(C_CHAR), DIMENSION(*) :: n
END SUBROUTINE more_arrays_etc

END INTERFACE
END MODULE module_function_tests
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_length_errors
USE, INTRINSIC :: iso_c_binding
implicit none
! Found excessively long name.
! INTEGER(C_INT), parameter, public :: this_macro_is_too_long_to_be_a_fortran_macro_because_there_are_line_limits_in_fortran = 1
INTERFACE
SUBROUTINE this_macr_name_is_exactly_63_characters_long_thus_should_be_ok() BIND(C)
! ;
END SUBROUTINE this_macr_name_is_exactly_63_characters_long_thus_should_be_ok
END INTERFACE
! Found excessively long name.
! INTEGER(C_INT), public, BIND(C) :: this_is_not_a_fancy_function_but_you_notice_that_it_is_also_too_long_for_fortran
REAL(C_DOUBLE), public, BIND(C) :: but_this_one_should_be_just_barely_short_enough_to_be_accepted_
REAL(C_DOUBLE), public, BIND(C) :: this_var_name_is_exactly_63_characters_long_thus_should_be_ok__
TYPE, BIND(C) :: this_struct_name_is_exactly_one_character_too_long_for_fortran_
    INTEGER(C_INT) :: this_struct_fild_is_exactly_one_character_too_long_for_fortran_
END TYPE this_struct_name_is_exactly_one_character_too_long_for_fortran_
! Found excessively long line.
! TYPE(this_struct_name_is_exactly_one_character_too_long_for_fortran_), public, BIND(C) :: this_struct_vari_is_exactly_one_character_too_long_for_fortran
TYPE, BIND(C) :: this_strct_name_is_exactly_63_characters_long_thus_should_be_ok
    INTEGER(C_INT) :: this_strct_fild_is_exactly_63_characters_long_thus_should_be_ok
END TYPE this_strct_name_is_exactly_63_characters_long_thus_should_be_ok
! Found excessively long line.
! TYPE(this_strct_name_is_exactly_63_characters_long_thus_should_be_ok), public, BIND(C) :: this_strct_vari_is_exactly_63_characters_long_thus_should_be_ok
! Found excessively long name.
! TYPE, BIND(C) :: this_typdef_name_is_exactly_one_character_too_long_for_fortran
!     INTEGER(C_INT)::this_typdef_name_is_exactly_one_character_too_long_for_fortran_C_INT
! END TYPE this_typdef_name_is_exactly_one_character_too_long_for_fortran
TYPE, BIND(C) :: this_typdf_name_is_exactly_63_characters_long_thus_should
    INTEGER(C_INT)::this_typdf_name_is_exactly_63_characters_long_thus_should_C_INT
END TYPE this_typdf_name_is_exactly_63_characters_long_thus_should
! Found excessively long name.
! ENUM, BIND(C) ! this_enum_name_is_exactly_one_character_too_long_for_fortran____
! ENUMERATOR :: this_enum_vari_is_exactly_one_character_too_long_for_fortran____ = 0
! END ENUM ! this_enum_name_is_exactly_one_character_too_long_for_fortran____
ENUM, BIND(C) ! this_enum_name_is_exactly_63_characters_long_thus_should_be_ok
ENUMERATOR :: this_enum_vari_is_exactly_63_characters_long_thus_should_be_ok = 0
END ENUM ! this_enum_name_is_exactly_63_characters_long_thus_should_be_ok
INTERFACE
! Found excessively long line.
! INTEGER(C_INT) FUNCTION this_function_will_produce_lines_too_long_woe_is_us(argument1, argument2, argument3, argument4, argument5, argument6) BIND(C)
!     USE iso_c_binding, only: C_CHAR, C_DOUBLE, C_INT, C_PTR
!     import
!     INTEGER(C_INT), value :: argument1
!     REAL(C_DOUBLE), value :: argument2
!     TYPE(C_PTR), value :: argument3
!     CHARACTER(C_CHAR), value :: argument4
!     TYPE(C_PTR), value :: argument5
!     INTEGER(C_INT), value :: argument6
! END FUNCTION this_function_will_produce_lines_too_long_woe_is_us
! 
! Found excessively long line.
! SUBROUTINE this_function_will_also_produce_lines_too_long_woe_is_us(argument1, argumnet2, argument3, argument4, argument5, argumnet6) BIND(C)
!     USE iso_c_binding, only: C_CHAR, C_DOUBLE, C_INT, C_PTR
!     import
!     INTEGER(C_INT), value :: argument1
!     REAL(C_DOUBLE), value :: argumnet2
!     TYPE(C_PTR), value :: argument3
!     CHARACTER(C_CHAR), value :: argument4
!     TYPE(C_PTR), value :: argument5
!     INTEGER(C_INT), value :: argumnet6
! END SUBROUTINE this_function_will_also_produce_lines_too_long_woe_is_us
! 
! Found excessively long name.
! INTEGER(C_INT) FUNCTION this_function_is_exactly_one_character_too_long_for_fortran_woe_() BIND(C)
!     USE iso_c_binding, only: C_INT
!     import
! END FUNCTION this_function_is_exactly_one_character_too_long_for_fortran_woe_
! 
! Found excessively long name.
! SUBROUTINE this_subroutn_is_exactly_one_character_too_long_for_fortran_woe_() BIND(C)
!     USE iso_c_binding
!     import
! END SUBROUTINE this_subroutn_is_exactly_one_character_too_long_for_fortran_woe_
! 
REAL(C_DOUBLE) FUNCTION this_func_name_is_exactly_63_characters_long_thus_should_be_ok_() BIND(C)
    USE iso_c_binding, only: C_DOUBLE
    import
END FUNCTION this_func_name_is_exactly_63_characters_long_thus_should_be_ok_

SUBROUTINE this_subr_name_is_exactly_63_characters_long_thus_should_be_ok() BIND(C)
    USE iso_c_binding
    import
END SUBROUTINE this_subr_name_is_exactly_63_characters_long_thus_should_be_ok

END INTERFACE
END MODULE module_length_errors
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_macro_suffixes
USE, INTRINSIC :: iso_c_binding
implicit none
INTEGER(C_LONG_LONG), parameter, public :: my_long_long = 10000000000
INTEGER(C_LONG_LONG), parameter, public :: my_u_long_long = 10000000000
REAL(C_FLOAT), parameter, public :: my_float = 25
REAL(C_LONG_DOUBLE), parameter, public :: exp_check = .0075e5
! Found unrecognized macro.
! bad_exp .045e3E4
REAL(C_FLOAT), parameter, public :: my_other_float = 90
REAL(C_LONG_DOUBLE), parameter, public :: my_long_float = 100000000.0
! Found unrecognized macro.
! my_illegal_float 1000.0LL
! Found unrecognized macro.
! my_illegal_float_2 10000.5fL
INTEGER(C_INT), parameter, public :: my_int_parens = -5
REAL(C_FLOAT), parameter, public :: my_float_parens = -45.4
INTEGER(C_LONG), parameter, public :: my_hex = Z'ff03b'
INTEGER(C_INT), parameter, public :: my_hex_u = Z'ff02bf'
INTEGER(C_INT), parameter, public :: my_oct_u = O'234'
INTEGER(C_LONG_LONG), parameter, public :: my_oct_l_l = O'424235'
INTEGER(C_LONG), parameter, public :: my_bin_l = B'0101'
INTEGER(C_INT), parameter, public :: my_bin_u = B'0101'
INTEGER(C_INT), parameter, public :: my_bin_u_paren = B'1010'
INTEGER(C_INT), parameter, public :: my_bin_paren = B'1010'
! Found unrecognized macro.
! illegal_1 343uu
! Found unrecognized macro.
! illegal_2 432LLLu
! Found unrecognized macro.
! illegal_3 0452lLuU
! Found unrecognized macro.
! illegal_4 343.0ff
! Found unrecognized macro.
! illegal_5 3420fL
END MODULE module_macro_suffixes
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_macro_tests
USE, INTRINSIC :: iso_c_binding
implicit none
INTEGER(C_INT), parameter, public :: my_integer = 45
REAL(C_DOUBLE), parameter, public :: my_double = 34.5
INTEGER(C_INT), parameter, public :: my_binary = B'10101101'
INTEGER(C_INT), parameter, public :: my_binary_caps = B'000'
! Found unrecognized macro.
! my_not_binary 0B20
! Found unrecognized macro.
! another_not_bin b10101
INTEGER(C_INT), parameter, public :: my_odd_hex = Z'00ff'
INTEGER(C_INT), parameter, public :: yet_another_hex = Z'ff00'
INTEGER(C_INT), parameter, public :: my_octal = O'5234'
INTEGER(C_INT), parameter, public :: not_octal = 08323
INTEGER(C_LONG), parameter, public :: my_other_not_octal = 0832
INTEGER(C_LONG), parameter, public :: my_other_int = 345
INTEGER(C_LONG), parameter, public :: my_unsigned_int = 45
INTEGER(C_INT), parameter, public :: my_hex = Z'345'
INTEGER(C_INT), parameter, public :: my_other_hex = Z'fedab'
! Found unrecognized macro.
! my_not_hex 0xfg01
! Found unrecognized macro.
! other_not_hex xf01a
INTEGER(C_LONG), parameter, public :: my_long = 123
CHARACTER(1), parameter, public :: my_char = 'a'
CHARACTER(8), parameter, public :: my_string = "a string"
INTERFACE
SUBROUTINE my_arg_macro(x, y) BIND(C)
!  x + y
END SUBROUTINE my_arg_macro
END INTERFACE
INTERFACE
SUBROUTINE swap_trick(x, y) BIND(C)
!  {x ^= y; y ^= x; x ^= y;}
END SUBROUTINE swap_trick
END INTERFACE
INTERFACE
SUBROUTINE multi_line(x) BIND(C)
!  {  \
!     x++;  \
!     x--;  \
! }
END SUBROUTINE multi_line
END INTERFACE
END MODULE module_macro_tests
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_name_conflicts
USE, INTRINSIC :: iso_c_binding
implicit none
INTEGER(C_INT), parameter, public :: y = 1
TYPE, BIND(C) :: x
    INTEGER(C_INT) :: placeholder
END TYPE x
! Found duplicate identifier.
! INTEGER(C_INT), public, BIND(C) :: x
! Found duplicate identifier.
! TYPE, BIND(C) :: y
!     INTEGER(C_INT) :: placeholder
! END TYPE y
TYPE, BIND(C) :: z
    INTEGER(C_INT) :: placeholder
END TYPE z
! Found duplicate identifier.
! TYPE, BIND(C) :: z
!     TYPE(C_PTR)::z_C_PTR
! END TYPE z
TYPE, BIND(C) :: n
    INTEGER(C_INT) :: placeholder
END TYPE n
! Found duplicate identifier.
! INTEGER(C_INT), public, BIND(C) :: n(1)
INTEGER(C_INT), public, BIND(C) :: h2m_v
! Found duplicate identifier.
! TYPE, BIND(C) :: h2m_v
!     INTEGER(C_INT) :: placeholder
! END TYPE h2m_v
! Found duplicate identifier.
! INTEGER(C_INT), public, BIND(C) :: h2m_v
END MODULE module_name_conflicts
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_prepend_tests
USE, INTRINSIC :: iso_c_binding
implicit none
INTEGER(C_INT), parameter, public :: h2m_bad_macro = 1
INTERFACE
SUBROUTINE h2m_bad_func_macro() BIND(C)
END SUBROUTINE h2m_bad_func_macro
END INTERFACE
INTEGER(C_INT), public, BIND(C) :: h2m_bad_int
CHARACTER(C_CHAR), public, BIND(C) :: h2m_bad_char_pointer
REAL(C_DOUBLE), public, BIND(C) :: h2m_bad_double_array(15)
TYPE(C_PTR), public, BIND(C) :: h2m_bad_char_pointer_array(3, 4)
TYPE, BIND(C) :: h2m_bad_struct
    INTEGER(C_INT) :: h2m_bad_struct_field
END TYPE h2m_bad_struct
TYPE(h2m_bad_struct), public, BIND(C) :: h2m_my_bad_struct_var
TYPE, BIND(C) :: h2m_bad_typedef_int
    INTEGER(C_INT)::h2m_bad_typedef_int_C_INT
END TYPE h2m_bad_typedef_int
ENUM, BIND(C) ! h2m_bad_enum
ENUMERATOR :: h2m_bad_enum_member = 0
ENUMERATOR :: h2m_bad_enum_member_two = 1
END ENUM ! h2m_bad_enum
INTERFACE
INTEGER(C_INT) FUNCTION h2m_bad_function(h2m_bad_argument) BIND(C)
    USE iso_c_binding, only: C_INT, C_PTR
    import
    TYPE(C_PTR), value :: h2m_bad_argument
END FUNCTION h2m_bad_function

TYPE(h2m_bad_struct) FUNCTION weird_function(my_bad, x) BIND(C)
    USE iso_c_binding, only: C_INT
    import
    TYPE(h2m_bad_struct), value :: my_bad
    INTEGER(C_INT), value :: x
END FUNCTION weird_function

END INTERFACE
END MODULE module_prepend_tests
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_struct_tests
USE, INTRINSIC :: iso_c_binding
implicit none
TYPE, BIND(C) :: x
    INTEGER(C_INT) :: my_int
    TYPE(C_PTR) :: my_pointer
    TYPE(C_PTR) :: my_struct_pointer
END TYPE x
TYPE, BIND(C) :: complicated
    TYPE(x) :: my_x
    INTEGER(C_INT) :: my_int
END TYPE complicated
TYPE, BIND(C) :: y
    REAL(C_DOUBLE) :: place_holder
END TYPE y
TYPE(y), public, BIND(C) :: my_y
TYPE, BIND(C) :: struct_y
    TYPE(y)::struct_y_y
END TYPE struct_y
! Found duplicate identifier.
! TYPE, BIND(C) :: y
!     TYPE(y)::y_y
! END TYPE y
TYPE, BIND(C) :: z
    TYPE(C_PTR) :: place_holder
END TYPE z
! Found duplicate identifier.
! TYPE, BIND(C) :: z
!     TYPE(z)::z_z
! END TYPE z
TYPE(z), public, BIND(C) :: my_z
TYPE(y), public, BIND(C) :: their_y = y(4.560000e+01)
END MODULE module_struct_tests
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_unrecongized_type
USE, INTRINSIC :: iso_c_binding
implicit none
! Found illegal type.
! TYPE, BIND(C) :: my_void_type
!     WARNING_UNRECOGNIZED(void)::my_void_type_WARNING_UNRECOGNIZED(void)
! END TYPE my_void_type
! Found illegal type.
! TYPE(h2m__va_list_tag), public, BIND(C) :: my_list(10, 1)
! Found illegal type.
! TYPE, BIND(C) :: va_list
!     TYPE(h2m__va_list_tag)::va_list_h2m__va_list_tag
! END TYPE va_list
! Found illegal type.
! TYPE(h2m__va_list_tag), public, BIND(C) :: my_va_list(1)
! Found illegal type.
! TYPE, BIND(C) :: my_struct
!     TYPE(h2m__va_list_tag) :: illegal(1)
! END TYPE my_struct
INTERFACE
! Found illegal type.
! INTEGER(C_INT) FUNCTION get_stuff(my_list) BIND(C)
!     USE iso_c_binding, only: C_INT
!     import
!     TYPE(h2m__va_list_tag), DIMENSION(1) :: my_list
! END FUNCTION get_stuff
! 
! Found illegal type.
! SUBROUTINE get_stuff2(my_list) BIND(C)
!     USE iso_c_binding
!     import
!     TYPE(h2m__va_list_tag), DIMENSION(*) :: my_list
! END SUBROUTINE get_stuff2
! 
END INTERFACE
END MODULE module_unrecongized_type
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_variable_tests
USE, INTRINSIC :: iso_c_binding
implicit none
INTEGER(C_INT), public, BIND(C) :: x
INTEGER(C_SHORT), public, BIND(C) :: my_short
INTEGER(C_LONG_LONG), public, BIND(C) :: my_long_long
INTEGER(C_SHORT), public, BIND(C) :: stuff(5, 5)
REAL(C_FLOAT), public, BIND(C) :: m
REAL(C_LONG_DOUBLE), public, BIND(C) :: not_my_stuff(10, 2)
REAL(C_DOUBLE), parameter, public :: y = 3.145000e+00
TYPE(C_PTR), public, BIND(C) :: z
TYPE(C_PTR), public, BIND(C) :: z2 !&x
TYPE(C_FUNPTR), public, BIND(C) :: function_pointer
! Found duplicate identifier.
! INTEGER(C_SHORT), public, BIND(C) :: my_short
INTEGER(C_LONG), public, BIND(C) :: my_long
CHARACTER(C_CHAR), parameter, public :: my_char = 'a'
CHARACTER(C_CHAR), public, BIND(C) :: my_car
END MODULE module_variable_tests
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_macro_suffixes
USE, INTRINSIC :: iso_c_binding
implicit none
INTEGER(C_LONG_LONG), parameter, public :: my_long_long = 10000000000
INTEGER(C_LONG_LONG), parameter, public :: my_u_long_long = 10000000000
REAL(C_FLOAT), parameter, public :: my_float = 25
REAL(C_LONG_DOUBLE), parameter, public :: exp_check = .0075e5
! Found unrecognized macro.
! bad_exp .045e3E4
REAL(C_FLOAT), parameter, public :: my_other_float = 90
REAL(C_LONG_DOUBLE), parameter, public :: my_long_float = 100000000.0
! Found unrecognized macro.
! my_illegal_float 1000.0LL
! Found unrecognized macro.
! my_illegal_float_2 10000.5fL
INTEGER(C_INT), parameter, public :: my_int_parens = -5
REAL(C_FLOAT), parameter, public :: my_float_parens = -45.4
INTEGER(C_LONG), parameter, public :: my_hex = Z'ff03b'
INTEGER(C_INT), parameter, public :: my_hex_u = Z'ff02bf'
INTEGER(C_INT), parameter, public :: my_oct_u = O'234'
INTEGER(C_LONG_LONG), parameter, public :: my_oct_l_l = O'424235'
INTEGER(C_LONG), parameter, public :: my_bin_l = B'0101'
INTEGER(C_INT), parameter, public :: my_bin_u = B'0101'
INTEGER(C_INT), parameter, public :: my_bin_u_paren = B'1010'
INTEGER(C_INT), parameter, public :: my_bin_paren = B'1010'
! Found unrecognized macro.
! illegal_1 343uu
! Found unrecognized macro.
! illegal_2 432LLLu
! Found unrecognized macro.
! illegal_3 0452lLuU
! Found unrecognized macro.
! illegal_4 343.0ff
! Found unrecognized macro.
! illegal_5 3420fL
END MODULE module_macro_suffixes
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_minitest
USE, INTRINSIC :: iso_c_binding
implicit none
INTEGER(C_INT), parameter, public :: bin_per = B'0110'
END MODULE module_minitest
! The following Fortran code was generated by the h2m-AutoFortran Tool.
! See the h2m README file for credits and help information.

MODULE module_mini
USE, INTRINSIC :: iso_c_binding
implicit none
! struct without fields may cause warnings
TYPE, BIND(C) :: simple
END TYPE simple
TYPE, BIND(C) :: mine
    INTEGER(C_INT) :: y
    REAL(C_DOUBLE) :: x
    CHARACTER(C_CHAR) :: z
END TYPE mine
! Found bad variable translation.
! TYPE(mine), public, BIND(C) :: my_unicorn
INTERFACE
TYPE(C_PTR) FUNCTION return_struct_pointer() BIND(C)
    USE iso_c_binding, only: C_PTR
    import
END FUNCTION return_struct_pointer

END INTERFACE
END MODULE module_mini
